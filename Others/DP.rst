==================
动态规划算法的介绍
==================

:Date:   2019-5-29

.. raw:: html

   <!-- more -->

.. raw:: html

   <!-- TOC -->

-  `概念 <#概念>`__
-  `两种形式 <#两种形式>`__

   -  `经典分治法求解 <#经典分治法求解>`__
   -  `自顶向下的备忘录 <#自顶向下的备忘录>`__
   -  `自底向上的动态规划 <#自底向上的动态规划>`__

-  `原理 <#原理>`__

   -  `①最优子结构 <#①最优子结构>`__
   -  `②重叠子问题 <#②重叠子问题>`__

-  `经典模型 <#经典模型>`__

   -  `1 线性模型 <#1-线性模型>`__
   -  `2 区间模型 <#2-区间模型>`__
   -  `3 背包模型 <#3-背包模型>`__
   -  `4 状态压缩模型 <#4-状态压缩模型>`__
   -  `5 树状模型 <#5-树状模型>`__

-  `常用状态转移方程 <#常用状态转移方程>`__


`动态规划 <http://cppblog.com/menjitianya/archive/2015/10/23/212084.html>`__
:download:`PDF版 <../files/DynamicProgramming.pdf>`

概念
=====

Dynamic programming:“programming”指的是一种\ **表格法**\ 。
**分治算法:**\ 将问题划分为互不相交的子问题，递归地求解子问题，再将他们的解组合起来。
**动态规划：**\ 应用于子问题重叠的情况，对每个子子问题值求解一次，将其解保存在一个表格中，避免了不必要的重复计算。

**步骤**\ ：

1. 刻画一个最优解的结构特征；
2. 递归地定义最优解的值；
3. 计算最优解的值，通常采用自底向上的方法；
4. 利用计算出来的信息构造出一个最优解。
   其\ **核心就是记住已解决过的子问题的解。**

两种形式
========

求斐波拉契数列Fibonacci ：

::

   Fibonacci (n) = 1;   n = 0
   Fibonacci (n) = 1;   n = 1
   Fibonacci (n) = Fibonacci(n-1) + Fibonacci(n-2)

经典分治法求解
--------------

递归求解：

::

   public int fib(int n)
   {
       if(n<=0)
           return 0;
       if(n==1)
           return 1;
       return fib( n-1)+fib(n-2);
   }

时间复杂度为指数。 ## 自顶向下的备忘录

::

   public static int Fibonacci(int n)
   {
       if(n<=0)
           return n;
       int []Memo=new int[n+1];        
       for(int i=0;i<=n;i++)
           Memo[i]=-1;
       return fib(n, Memo);
   }
   public static int fib(int n,int []Memo)
   {
       if(Memo[n]!=-1)
           return Memo[n];
   //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。       
       if(n<=2)
           Memo[n]=1;
       else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo);  
       return Memo[n];
   }

创建一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算；如果未计算出来，则计算出来后保存在Memo数组中。

自底向上的动态规划
------------------

::

   public static int fib(int n)
   {
       if(n<=1)
           return n;
       int Memo_i_2=0;
       int Memo_i_1=1;
       int Memo_i=1;
       for(int i=2;i<=n;i++)
       {
           Memo_i=Memo_i_2+Memo_i_1;
           Memo_i_2=Memo_i_1;
           Memo_i_1=Memo_i;
       }       
       return Memo_i;
   }

原理
====

虽然已经用动态规划方法解决了上面两个问题，但是大家可能还跟我一样并不知道什么时候要用到动态规划。总结一下上面的斐波拉契数列和钢条切割问题，发现两个问题都涉及到了重叠子问题，和最优子结构。

①最优子结构
-----------

用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。

②重叠子问题
-----------

在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping
subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。

经典模型
========

1 线性模型
----------

线性模型的是动态规划中最常用的模型，上文讲到的最长单调子序列就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。
【例题6】在一个夜黑风高的晚上，有n（n <=
50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。
我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i]
= opt[i-1] + a[1] + a[i]
(让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i]
= opt[i-2] + a[1] + a[i] + 2\ *a[2]
(让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)
所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] +
2*\ a[2] }

2 区间模型
----------

区间模型的状态表示一般为d[i][j]，表示区间[i,
j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i,
j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。
【例题7】给定一个长度为n（n <=
1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。
典型的区间模型，回文串拥有很明显的子结构特征，即当字符串X是一个回文串时，在X两边各添加一个字符’a’后，aXa仍然是一个回文串，我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数，那么对于A[i]
== A[j]的情况，很明显有 d[i][j] = d[i+1][j-1] （这里需要明确一点，当i+1
>
j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d[i+1][j-1]
= 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策：
1、在A[j]后面添加一个字符A[i]； 2、在A[i]前面添加一个字符A[j]；
根据两种决策列出状态转移方程为： d[i][j] = min{ d[i+1][j], d[i][j-1] } +
1; (每次状态转移，区间长度增加1)
空间复杂度O(n\ :sup:`2)，时间复杂度O(n`\ 2)，
下文会提到将空间复杂度降为O(n)的优化算法。

3 背包模型
----------

背包问题是动态规划中一个最典型的问题之一。由于网上有非常详尽的背包讲解，这里只将常用部分抽出来，具体推导过程详见《背包九讲》。
a.0/1背包 b.完全背包 c.多重背包
有N种物品（每种物品Mi件）和一个容量为V的背包。放入第i种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。
f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值。
f[i][v] = max{ f[i-1][v - kCi] + kWi \| 0 <= k <= Mi } 时间复杂度O(
Vsum(Mi) )，空间复杂度仍然可以用滚动数组优化后可以达到O( V )。
优化：采用二进制拆分物品，将Mi个物品拆分成容量为1、2、4、8、… 2^k、Mi-(
2^(k+1) - 1 ) 个对应价值为Wi、2Wi、4Wi、8Wi、…、2^kWi、（Mi-( 2^(k+1) -
1 )）Wi的物品，然后采用01背包求解。 这样做的时间复杂度降为O(Vsum(logMi)
)。

【例题8】一群强盗想要抢劫银行，总共N(N <=
100)个银行，第i个银行的资金为Bi亿，抢劫该银行被抓概率Pi，问在被抓概率小于p的情况下能够抢劫的最大资金是多少？
p表示的是强盗在抢银行时至少有一次被抓概率的上限，那么选择一些银行，并且计算抢劫这些银行都不被抓的的概率pc，则需要满足1
- pc < p。这里的pc是所有选出来的银行的抢劫时不被抓概率（即1 -
Pi）的乘积，于是我们用资金作为背包物品的容量，概率作为背包物品的价值，求01背包。状态转移方程为：
f[j] = max{ f[j], f[j - pack[i].B] \* (1-pack[i].p) }
最后得到的f[i]表示的是抢劫到 i
亿资金的最大不被抓概率。令所有银行资金总和为V，那么从V-0进行枚举，第一个满足1
- f[i] < p的i就是我们所要求的被抓概率小于p的最大资金。

4 状态压缩模型
--------------

状态压缩的动态规划，一般处理的是数据规模较小的问题，将状态压缩成k进制的整数，k取2时最为常见。
【例题9】对于一条n(n <=
11)个点的哈密尔顿路径C1C2…CN（经过每个点一次的路径）的值由三部分组成：
1、每个顶点的权值Vi的和
2、对于路径上相邻的任意两个顶点CiCi+1，累加权值乘积 Vi\ *Vi+1
3、对于相邻的三个顶点CiCi+1Ci+2，如果Ci和Ci+2之间有边，那么累加权值三乘积
Vi*\ Vi+1*Vi+2 求值最大的哈密尔顿路径的权值和这样的路径的个数。

采用二进制表示状态，用d[i][j][k]表示某条哈密尔顿路径的最大权值，其中i是一个二进制整数，它的第t位为1表示t这个顶点在这条哈密尔顿路径上，为0表示不在路径上。j和k分别为路径的最后两个顶点。那么图二-4-1表示的状态就是：
d[(11101111)2][7][1] （12056）——7——1
明确了状态表示，那么我们假设02356这5个点中和7直接相连的是i，于是就转化成了子问题…->j
-> i -> 7，我们可以枚举i = 0， 2， 3， 5， 6。 给出状态转移方程：
d[i][j][k] = max{ d[i ^ (1<<k)][t][j] + w(t, j, k) \| (i & (1<<t)) != 0
} 这里用到了几个位运算:i ^ (1<<k)表示将i的二进制的第k位从1变成0，i &
(1<<t)则为判断i的二进制表示的第t位是否为1，即该路径中是否存在t这个点。这个状态转移的实质就是将原本的
…->j -> k 转化成更加小规模的去掉k点后的子问题 … -> t -> j 求解。而w(t,
j, k)则表示
t->j->k这条子路径上产生的权值和，这个可以由定义在O(1)的时间计算出来。 d[
(1<<j) \| (1<<k) ][j][k]
为所有的两个点的路径的最大值，即最小的子问题。这个问题的状态并非线性的，所以用记忆化搜索来求解状态的值会事半功倍。

5 树状模型
----------

| 树形动态规划（树形DP），是指状态图是一棵树，状态转移也发生在树上，父结点的值通过所有子结点计算完毕后得出。
  【例题11】给定一颗树，和树上每个结点的权值，求一颗非空子树，使得权和最大。
| 用d[1][i] 表示i这个结点选中的情况下，以i为根的子树的权和最大值;
  用d[0][i]表示i这个结点不选中的情况下，以i为根的子树的权和最大值;

d[1][i] = v[i] + sum{ d[1][v] \| v是i的直接子结点 && d[1][v] > 0 }

d[0][i] = max( 0, max{ max( d[0][v], d[1][v] ) \| v是i的直接子结点 } )

这样，构造一个以1为根结点的树，然后就可以通过dfs求解了。

这题题目要求求出的树为非空树，所以当所有权值都为负数的情况下需要特殊处理，选择所有权值中最大的那个作为答案。

常用状态转移方程
================

动态规划算法三要素（摘自黑书，总结的很好，很有概括性）：
①所有不同的子问题组成的表 ②解决问题的依赖关系可以看成是一个图
③填充子问题的顺序（即对②的图进行拓扑排序，填充的过程称为状态转移）；
则如果子问题的数目为O(nt)，每个子问题需要用到O(ne)个子问题的结果，那么我们称它为tD/eD的问题，于是可以总结出四类常用的动态规划方程：
（下面会把opt作为取最优值的函数（一般取min或max）, w(j,
i)为一个实函数，其它变量都可以在常数时间计算出来）。) 1、1D/1D d[i] =
opt{ d[j] + w(j, i) \| 0 <= i < j } (1 <= i <= n) 2、2D/0D d[i][j] =
opt{ d[i-1][j] + xi, d[i][j-1] + yj, d[i-1][j-1] + zij } (1<= i, j <= n)
3、2D/1D d[i][j] = w(i, j) + opt{ d[i][k-1] + d[k][j] }, (1 <= i < j <=
n) 区间模型常用方程。 另外一种常用的2D/1D的方程为： d[i][j] = opt{
d[i-1][k] + w(i, j, k) \| k < j } (1<= i <= n, 1 <= j <= m) 4、2D/2D
d[i][j] = opt{ d[i’][j’] + w(i’, j’, i, j) \| 0 <= i’ < i, 0 <= j’ < j}
常见于二维的迷宫问题，由于复杂度比较大，所以一般配合数据结构优化，如线段树、树状数组等。
对于一个tD/eD
的动态规划问题，在不经过任何优化的情况下，可以粗略得到一个时间复杂度是O(nt+e)，空间复杂度是O(nt)的算法，大多数情况下空间复杂度是很容易优化的，难点在于时间复杂度，下一章我们将详细讲解各种情况下的动态规划优化算法。
